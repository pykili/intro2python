# Импорт и создание модулей

## Задача на рекурсию
Напишите функцию `flatten()`, которая принимает на вход список, состоящий из других списков, и возвращает обычный список, в котором присутствуют все элементы из вложенных списков. Эта операция производится при помощи рекурсии.
    
```python
>>> print(flatten([[1, 2], [3, 4], 5, [6, [7]]]))
<<< [1, 2, 3, 4, 5, 6, 7]
```

## Импорт модулей стандартной библиотеки

Питон включает в себя обширную библиотеку модулей, в которых реализовано множество полезных функций. В этом курсе мы применяли и еще будем применять такие модули как [`re`](https://docs.python.org/3/library/re.html) для регулярных выражений, [`collections`](https://docs.python.org/3/library/collections.html), содержащий множество удобных структур данных, [`os`](https://docs.python.org/3/library/os.html) и [`shutil`](https://docs.python.org/3/library/shutil.html) для управления файлами и папками, [`sys`](https://docs.python.org/3/library/sys.html) для взаимодействия с интерпретатором (всегда доступен специфичен для системы).

Правило хорошего тона $-$ импортировать модули вначале вашей программы, до любого другого кода и функций и пропускать одну строку перед кодом по PEP-8.

Для использования модуля его нужно импортировать — попросить питон загрузить его и сделать его функции доступными для использования. Импорт осуществляется с помощью оператора `import`. Например, модуль [`random`](https://docs.python.org/3/library/random.html) используется для генерации "случайных" чисел.

```python
import random

print(random.randint(0, 5))  # выводит случайное целое число между 0 и 5 включительно
print(random.choice('abcdef'))  # выберает случайный элемент коллекции
print(random.random())  # Выводит случайное число на полуинтервале [0, 1)
```
```
2
c
0.9131300358342321
```


Ещё один пример: модуль `math`, содержащий различные математические функции и константы.

```python
print(math.cos(0))  # ошибка, модуль ещё не импортирован

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
Cell In[4], line 1
----> 1 print(math.cos(0))

NameError: name 'math' is not defined
```

```python
import math

print(math.cos(0))
print(math.asin(1))
print(math.e)
```
```
1.0
1.5707963267948966
2.718281828459045
```

### Импорт нескольких модулей

Модули можно импортировать в одну строчку через запятую, если требуется использовать несколько, либо можно писать каждый импорт на новой строчке. Некоторая проблема заключается в том, что по PEP-8 первый вариант через запятую не одобряется, но знать не лишнее.

```python
import random, math

print(math.sqrt(random.randint(0, 5)))
```
```
2.23606797749979
```

Лучше все же так:

```python
import random
import math

print(math.sqrt(random.randint(0, 5)))
```
```
2.0
```

### Инструкция from

Как вы могли заметить, в модуле бывает много разных функций. Если вам нужно использовать только что-то одно (и, например, использовать много раз), тогда проще импортировать какую-то определенную функцию из этого модуля и (1) чуть-чуть сэкономить память, (2) **упростить синтаксис**. Тогда синтаксис импорта будет следующий:

```python
from math import ceil, floor

print(ceil(145.3))
print(floor(145.6))
```
```
146
145
```

Также можно импортировать из модуля всё. То есть **все функции, переменные и классы**. Тогда нам не нужно каждый раз писать название модуля.

```python
from math import *

print(sqrt(144))
print(pi)
```
```
12.0
3.141592653589793
```

Однако это очень плохая практика, так как в двух разных модулях могут быть одинаковые функции и при импорте вы просто не будете знать, какую используете. Подробнее на эту проблему посмотрим ниже.

### Использование псевдонимов

По-английски называется *aliasing*. Если вы не хотите писать название модуля / функции каждый раз, когда используете их, вы можете импортировать их под псевдонимом с помощью `as`:

```python
import math as m

print(m.factorial(5))
```
```
120
```

Или даже так:

```python
from math import factorial as fact

print(fact(5))
```
```
120
```

## Создание своего модуля

Любой PY-файл с исходным кодом на Python $-$ это модуль! Это значит, что любая программа может выступать в роли модуля для другой и импортироваться.

Давайте напишем скрипт с парой функций и импортируем эти функции в другую программу.

Создадим программу `mymodule.py`:

```python
# mymodule.py
def avg(numbers: list[int | float]) -> float:
    '''
    Функция, которая возвращает среднее от списка.
    '''
    if not numbers:
        return 0
    return sum(numbers) / len(numbers)


def myfactorial(n: int) -> int | str:
    '''
    Функция, которая возвращает n! (факториал от n).
    '''
    if n == 1:
        return n
    elif n < 1:
        return "NA"
    else:
        return n * myfactorial(n - 1)
```

В ней мы прописали две математические функции: среднее и факториал. Предположим, теперь мы хотим воспользоваться ими в какой-нибудь другой программе. Тогда мы положим эти два файла в **одну директорию**, чтобы импорт работал. И в результате мы сможем импортировать эти функции в новую программу.

```python
# или from mymodule import avg, myfactorial
import mymodule

n = input("Введите число: ")
my_list = [1] * (int(n) // 2) + [2] * (int(n) // 2)

print(mymodule.avg(my_list))
print(mymodule.myfactorial(int(n)))
```

Добавим чуть-чуть в наш файл `mymodule.py`:

```python
# mymodule.py
my_favourite_number = 13  # глобальная переменная с любимым числом

def avg(numbers: list[int | float]) -> float:
    '''
    Функция, которая возвращает среднее от списка.
    '''
    if not numbers:
        return 0
    return sum(numbers) / len(numbers)


def myfactorial(n: int) -> int | str:
    '''
    Функция, которая возвращает n! (факториал от n).
    '''
    if n == 1:
        return n
    elif n < 1:
        return "NA"
    else:
        return n * myfactorial(n - 1)
```

Важно сказать, что каждый модуль / пакет импортируется лишь один раз за сессию, поэтому, чтобы изменения внеслись, иногда надо перезапустить интерпретатор или сделать так:

```python
import importlib

importlib.reload(mymodule)
```

Все, теперь мы можем сделать так:

```python
from mymodule import my_favourite_number

print(my_favourite_number)
```
```
13
```

Теперь должно стать чуть понятнее, почему мы можем не хотеть делать `from mymodule import *`...

А сейчас откатимся на пару шагов назад. Чем импорт самописного модуля отличается от импорта встроенного модуля? На самом деле, ничем. 

Мы можем легко найти папку где лежит такой же PY-файл (на самом деле, он спрятан там же, где спрятан сам питон):

```python
import pprint

print(pprint.__file__)
```

И тут важна приоритетность. Если вы попытаетесь создать файл `pprint.py` в своей директории, то приоритетнее все еще будет тот, что лежит ближе к питону.

## Запуск скрипта

Надеюсь, ни для кого не секрет, что мы можем записать в файл `testmymodule.py` что-то подобное:

```python
# testmymodule.py
import mymodule

n = input("Введите число: ")
my_list = [1] * (int(n) // 2) + [2] * (int(n) // 2)

print(mymodule.avg(my_list))
print(mymodule.myfactorial(int(n)))
```

А потом можем запустить наш PY-скрипт в терминале так.

```sh
python testmymodule.py
```

А что если мы не хотим создавать для этого отдельный файл, а хотим через терминал проверить? Без проблем!

Можем добавить в `mymodule.py` что-то подобное:

```python
# mymodule.py
if __name__ == "__main__":
    n = int(sys.argv[1])
    
    my_list = [1] * (int(n) // 2) + [2] * (int(n) // 2)

    print(myfactorial(n))
    print(avg(my_list))
```

И теперь запускать через терминал так:

```sh
python mymodule.py 5
```

А что вообще сейчас произошло..?

На самом деле, мы просто явно указали точку входа (может быть сделано только в модулях). Для этого используется специальная переменная `__name__`, в которой содержится наименование текущего модуля или пакета. Если мы явно передали текущий модуль на исполнение (например, в терминал), то он называется `__main__` независимо от названия файла (наследие предков...).

## Пакеты

Если у нас несколько модулей, то мы можем их организовать в один пакет (*package*). Пример ниже:

```
seminars/                       Пакет верхнего уровня
      __init__.py               Инициализация пакета seminars
      py_one/                   Подпакет с файлами для семинаров 1-го курса
              __init__.py
              mymodule.py
              fibonacci.py
              hanoi.py
              recursion.py
              ...
      py_two/                   Подпакет с файлами для семинаров 2-го курса
              __init__.py
              morphology.py
              my_flask.py
              tg_bot.py
              ...
```

Файлы `__init.py__` $-$ это внутренняя кухня питона. В дефолтном случае они нужны для инициализации каждый своего (под)пакета и могут быть пустыми. В более сложном случае в них может быть прописан `__all__`, который и отвечает за установку в случае `from seminars.py_one import *`. Например, так:

```python
# __init__.py в py_one
__all__ = ["fibonacci", "hanoi"]
```

Можно импортировать отдельные модули из пакета, но просто импортировать пакет нельзя:

```python
# import seminars - это бред
import seminars.py_one.mymodule

print(seminars.py_one.mymodule.myfactorial(10))
```

Или же:

```python
from seminars.py_one import mymodule

print(mymodule.myfactorial(10))
```

Если нам надо как-то подниматься между папками, то для этого тоже нужны `.`:

```python
# my_flask.py 
from . import morphology
from ..py_one import mymodule
```

## Задача

Пусть какая-то функция получает на вход список из 30 случайных целых чисел от 0 до 100, сгенерированных с помощью модуля `random`. Функция перемешивает список, сравнивает его с исходным списком и возвращает количество индексов, значение элемента по которым поменялось. Запустите функцию в цикле 100 раз и напечатайте в скольки процентов случаев меняются все элементы списка.
